\chapter{Исследовательский раздел}
\section{Технические характеристики}
Технические характеристики устройства, на котором выполнялось тестирование:
\begin{itemize}
	\item операционная система: Windows 10 Pro;
	\item память: 8 GiB;
	\item процессор: Intel(R) Core(TM) i5-8265U CPU @ 1.60GHz   1.80 GHz.
\end{itemize}
Тестирование проводилось на ноутбуке, который был подключен к сети питания. Во время проведения тестирования ноутбук был нагружен только встроенными приложениями окружения, самим окружением и системой тестирования.

\section{Время выполнения}
Проведем анализ времени работы алгоритмов для лучшего, обычного и худшего случаев. Исходными
данными является массив целых чисел. Единичные замеры выдадут крайне малень-
кий результат, поэтому проведем работу каждого алгоритма n = 100 раз
и поделим на число n. Получим среднее значение работы каждого из
алгоритмов.

Выполним анализ для лучшего случая, когда массив целых чисел упорядочен по возрастанию. Результат приведен на рисунке \ref{fg:ref1}.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\begin{axis}
			[grid = major,
			xlabel = Размер матрицы,
			ylabel = {Время, c},
			ymin = 0,
			width = 0.95\textwidth,
			height=0.3\textheight,
			legend style={at={(0.5,-0.2)},anchor=north},
			xmajorgrids=true]
			\addplot table{data/best_pancake_time.txt};
			\addplot table{data/best_quick_time.txt};
			\addplot table{data/best_select_time.txt};
			\legend{
				Блинная,
				Быстрая,
				Выбором
			};
		\end{axis}
	\end{tikzpicture}
	\caption{Зависимость времени работы алгоритмов сортировки для лучшего случая.} 
	\label{fg:ref1}
\end{figure} 

Рекурсивная реализация быстрой сортировки для лучшего случая выполняется медленнее остальных рассмотренных алгоритмов для 800 элементов массива в среднем в 2 раза. В дальнейшем этот отрыв увеличивается. Блинная и сортировка выбором имеют разницу во времени выполнения в среднем на 1-3\%. 

Выполним анализ для обычного случая, когда массив целых чисел имеет случайные значения. Результат приведен на рисунке \ref{fg:ref2}.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\begin{axis}
			[grid = major,
			xlabel = Размер массива,
			ylabel = {Время, c},
			ymin = 0,
			width = 0.95\textwidth,
			height=0.3\textheight,
			legend style={at={(0.5,-0.2)},anchor=north},
			xmajorgrids=true]
			\addplot table{data/usual_pancake_time.txt};
			\addplot table{data/usual_quick_time.txt};
			\addplot table{data/usual_select_time.txt};
			\legend{
				Блинная,
				Быстрая,
				Выбором
			};
		\end{axis}
	\end{tikzpicture}
	\caption{Зависимость времени работы алгоритмов сортировки для обычного случая.} 
	\label{fg:ref2}
\end{figure}
При случайной генерации массива быстрая сортировка оправдывает свое название. Разница с блинной сортировкой составляет в среднем 32,5 раза для 600 элементов и 48 раз для 900. Разница сортировки выбором и быстрой составляет 13,7 раз для 600 элементов и 19,3 раз для 900. Время выполнения сортировок начинается отличаться уже при 200 элементов массива.

Выполним анализ для худшего случая, когда массив целых чисел отсортирован в обратном порядке. Результат приведен на рисунке \ref{fg:ref3}.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\begin{axis}
			[grid = major,
			xlabel = Размер массива,
			ylabel = {Время, c},
			ymin = 0,
			width = 0.95\textwidth,
			height=0.3\textheight,
			legend style={at={(0.5,-0.2)},anchor=north},
			xmajorgrids=true]
			\addplot table{data/worst_pancake_time.txt};
			\addplot table{data/worst_quick_time.txt};
			\addplot table{data/worst_select_time.txt};
			\legend{
				Блинная,
				Быстрая,
				Выбором
			};
		\end{axis}
	\end{tikzpicture}
	\caption{График зависимости времени работы алгоритмов сортировки для худшего случая.} 
	\label{fg:ref3}
\end{figure}

Для худшего случая быстрая сортировка вновь проигрывает по времени выполнения блинной и быстрой в среднем в 1,7 раз.

\section{Затраты по памяти реализаций алгоритмов}

Введем следующие обозначения:
\begin{itemize}
	\item $\text{size}(a)$~--- функция, вычисляющая размер входного параметра $a$ в байтах;
	\item $int$~--- целочисленный тип данных.
\end{itemize}

Теоретически оценим объем используемой алгоритмами памяти при сортировке массива размером $N$.

\subsection{Блинная сортировка}
Оценка используемой блинной сортировкой памяти приведена в (\ref{eq:mem_pancake}):
\begin{equation}
	\label{eq:mem_pancake}
	M_{PancakeSort} = 2 \cdot \text{size}(int) + N \cdot \text{size}(int) + 8 \cdot 3N + 8 \cdot N,
\end{equation}
где
\begin{itemize}
	\item $2 \cdot \text{size}(int)$~--- дополнительные переменные;
	\item $N \cdot \text{size}(int)$~--- массив блоков;
	\item $8$~--- указатель на массив, переданный в качестве параметра;
	\item $8$~--- адрес возврата.
\end{itemize}

\subsection{Быстрая сортировка}

Оценка используемой быстрой сортировкой памяти приведена в \ref{eq:mem-qsort}:

\begin{equation}
	\label{eq:mem-qsort}
	M_{QuickSort} = M_{call} \cdot
	\begin{cases}
		\log_2{N}, & \text{лучший}, \\
		N, & \text{худший}
	\end{cases}
\end{equation}
где
\begin{itemize}
	\item $M_{call} = (8 + 3 \cdot \text{size}(int) + 8$~--- память, затрачиваемая на один рекурсивный вызов ($8$~--- адрес возврата, $3 \cdot \text{size}(int)$~---дополнительные переменные, $8$~--- указатель на массив);
	\item $\log_2{N}$~--- глубина стека вызовов в лучшем случае;
	\item $N$~--- глубина стека вызовов в худшем случае.
\end{itemize}

Тогда итоговая формула
\begin{equation}
	\label{eqn:mem-qsort}
	M_{QuickSort} = (8 + 3 \cdot \text{size}(int) + N \cdot \text{size}(int)) \cdot
	\begin{cases}
		\log_2{N}, & \text{лучший}, \\
		N, & \text{худший}
	\end{cases}
\end{equation}

\subsection{Сортировка выбором}

Оценка используемой сортировкой выбором памяти приведена в (\ref{eq:mem_select}):
\begin{equation}
	\label{eq:mem_select}
	M_{SelectSort} = 4 \cdot \text{size}(int) + 8,
\end{equation}
где
\begin{itemize}
	\item $4 \cdot \text{size}(int)$~--- дополнительные переменные;
	\item $8$~--- указатель на массив, переданный в качестве параметра.
\end{itemize}

\section*{Вывод}
В результате замеров времени выполнения реализаций различных алгоритмов было выявлено, что рекурсивная реализация быстрой сортировки для лучшего случая выполняется медленнее остальных рассмотренных алгоритмов для 800 элементов массива в среднем в 2 раза. В дальнейшем этот отрыв увеличивается. Блинная и сортировка выбором имеют разницу во времени выполнения в среднем на 1-3\%. 

При случайной генерации массива быстрая сортировка оправдывает свое название. Разница с блинной сортировкой составляет в среднем 32,5 раза для 600 элементов и 48 раз для 900. Разница сортировки выбором и быстрой составляет 13,7 раз для 600 элементов и 19,3 раз для 900. Время выполнения сортировок начинается отличаться уже при 200 элементов массива.

Для худшего случая быстрая сортировка вновь проигрывает по времени выполнения блинной и быстрой в среднем в 1,7 раз.

В результате теоретической оценки алгоритмов по памяти показано, что алгоритм сортировки выбором является наименее ресурсозатратным по сравнению с блинной и быстрой.
Алгоритм быстрой сортировки, напротив, требует больше всего памяти, что объясняется тем, что алгоритм рекурсивный, и на каждый вызов функции требуется выделение памяти на стеке для сохранения информации, связанной с этим вызовом.