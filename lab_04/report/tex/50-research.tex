\chapter{Исследовательский раздел}
\section{Технические характеристики}
Технические характеристии устройства, на котором выполнялось тестирование:
\begin{itemize}
	\item операционная система: Ubuntu 20.04;
	\item память: 8 GiB;
	\item процессор: Intel(R) Core(TM) i5-8265U CPU @ 1.60GHz   1.80 GHz;
	\item количество ядер: 4;
	\item количество логических ядер: 8.
\end{itemize}
Тестирование проводилось на ноутбуке, который был подключен к сети питания. Во время проведения тестирования ноутбук был нагружен только встроенными приложениями окружения, самим окружением и системой тестирования.
\newpage
\section{Последовательное выполнение}
Проведем анализ сравнения времени расчета реализации последовательного алгоритма от длины массива для $N \in \{1000, 2000, 3000, 4000, ..., 10000\}$. Проведем работу каждого из них n = 100 раз и поделим на число n. Получим среднее значение работы каждого из алгоритмов.

На рисунке \ref{fg:6_1} приведена зависимость времени работы последовательного алгоритма сортировки слиянием от размера массива.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\begin{axis}
			[grid = major,
			xlabel = Длина массива,
			ylabel = {Время, c},
			ymin = 0,
			width = 0.95\textwidth,
			height=0.3\textheight,
			legend style={at={(0.5,-0.3)},anchor=north},
			xmajorgrids=true]
			
			\addplot table{data/time_input_size.txt};
			\legend{
				Последовательный
			};
		\end{axis}
	\end{tikzpicture}
	\caption{Зависимость времени работы последовательного алгоритма сортировки слиянием от размера массива} 
	\label{fg:6_1}
\end{figure}
\newpage
\section{Последовательное и параллельное выполнение алгоритма}
Проведем анализ сравнения времени расчета реализаций последовательного алгоритма и параллельного с одним вспомогательным потоком для длины массива для $N \in \{1000, 2000, 3000, 4000, ..., 10000\}$. Проведем работу каждого из них n = 100 раз и поделим на число n. Получим среднее значение работы каждого из алгоритмов.

На рисунке \ref{fg:6_2} приведены зависимости времени работы версии алгоритмов от размеров массива.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\begin{axis}
			[grid = major,
			xlabel = Длина массива,
			ylabel = {Время, c},
			ymin = 0,
			width = 0.95\textwidth,
			height=0.3\textheight,
			legend style={at={(0.5,-0.3)},anchor=north},
			xmajorgrids=true]
			
			\addplot table{data/time_input_size.txt};
			\addplot table{data/time_1_add_thread.txt};
			\legend{
				Последовательный,
				С использованием 1 вспомогательного потока
			};
		\end{axis}
	\end{tikzpicture}
	\caption{Зависимости времени работы версии алгоритмов от размеров массива} 
	\label{fg:6_2}
\end{figure}

\newpage
Проведем анализ времени работы алгоритма для последовательной и параллельной реализации алгоритмов сортировки слиянием. Проведем работу каждого из них n = 100 раз и поделим на число n. Получим среднее значение работы каждого из алгоритмов. Для параллельного алгоритма выполнение вычислений производилось на $K \in \{1, 2, 4, 8, 16, ... ,8 \cdot Q\}$ потоках, где $Q$ -- число
логических ядер представленной ЭВМ.

На рисунке \ref{fg:6_3} приведена зависимость времени работы параллельного алгоритма сортировки слиянием от числа используемых потоков.
\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\begin{axis}
			[grid = major,
			xlabel = Число ядер,
			ylabel = {Время, c},
			xmin=0,
			ymin = 0.0007,
			xtick={1, 2, 4, 8, 16, 32, 64},
			width = \textwidth,
			height=0.3\textheight,
			legend style={at={(0.5,-0.3)},anchor=north},
			xmajorgrids=true]
			
			\addplot table{data/time_n_kernels.txt};
			\legend{
				Параллельный
			};
		\end{axis}
	\end{tikzpicture}
	\caption{Зависимость времени работы параллельного алгоритма сортировки слиянием от числа используемых потоков} 
	\label{fg:6_3}
\end{figure}

\section*{Вывод}
Использование одного вспомогательного потока не является целесообразным решением, поскольку необходимо тратить дополнительные операции по его созданию, выделению ему ресурсов, а также его уничтожения. В результате эксперимента было получено, что при использовании 8 потоков время многопоточной реализации алгоритма сортировки слиянием меньше остальных рассмотренных случаев. 