\chapter{Аналитический раздел}
\section{Расстояние Левенштейна}
Расстояние Левенштейна (редакторское расстояние) между двумя строками представляет собой минимальное количество операций вставки, удаления и замены, необходимых для превращения одной строки в другую \cite{levenstein}.

При преобразовании одной строки в другую используются следующие операции \cite{levenstein}:

\begin{itemize}
	\item I (англ. \textit{insert}) -- вставка;
	\item D (англ. \textit{delete}) -- удаление;
	\item R (англ. \textit{replace}) -- замена;
	\item M (англ. \textit{match}) -- совпадение.
\end{itemize}

Штрафом называется стоимость каждой из этих операций. Для вставки, удаления, замены значение принимается 1, для совпадения -- 0 \cite{levenstein}.  

Необходимо найти последовательность замен с минимальным суммарным штрафом.

\subsection{Рекуррентный алгоритм}
Пусть $s_{1}$ и $s_{2}$ -- две строки длиной $M$ и $N$ соответственно над некоторым алфавитом. Расстояние между $s_{1}$ и $s_{2}$ рассчитывается по рекуррентной \text{формуле (\ref{eq:leven_recur})}.
\begin{equation}
	\label{eq:leven_recur}
	D(i, j) =
	\begin{cases}
		0, &\text{i = 0, j = 0,}\\
		i, &\text{j = 0, i > 0,}\\
		j, &\text{i = 0, j > 0,}\\
		\text{min}  \lbrace
		D(i, j - 1) + 1,\\
		D(i - 1, j) + 1, &\text{i > 0, j > 0,}\\
		D(i - 1, j - 1) +  f(s_{1}[i], s_{2}[j]), \\
		\rbrace.
		
	\end{cases}
\end{equation}

где $i$, $j$ -- длины подстроки $s_{1}[1..i]$ и $s_{2}[1..j]$ соответственно, а функция $f(s_{1}, s_{2})$ определяется по формуле (\ref{eq:add_func}):
\begin{equation}
	f(s_{1}, s_{2}) =
	\begin{cases}
		0, s_{1}=s_{2}\\
		1, \text{иначе}
	\end{cases}.
	\label{eq:add_func}
\end{equation}

\subsection{Матрица расстояний}
\label{section:mtrx_dist}
При обработке строк с б\'ольшими значениями длин $M$ и $N$ реализация алгоритма по рекуррентной формуле (\ref{eq:leven_recur}) становится менее эффективной по временным затратам, поскольку требуется многократное вычисление промежуточных результатов. Для оптимизации нахождения расстояния Левенштейна необходимо использовать матрицу стоимостей для хранения этих промежуточных значений. В таком случае алгоритм представляет собой построчное заполнение матрицы значениями $D(i, j)$.

\subsection{Использование двух строк}
Модификацией использования матрицы расстояний является использование только двух строк этой матрицы, в которых хранятся промежуточные значения. После завершения вычислений происходит обмен значениями между этими двумя строками. Далее в ходе выполнения алгоритма перезаписываются значения только второй строки.

\subsection{Рекурсивный алгоритм с кэшем в форме матрицы}
При помощи матрицы можно выполнить оптимизацию рекурсивного алгоритма заполнения. Основная идея такого подхода заключается в том, что при каждом рекурсивном вызове алгоритма выполняется заполнение матрицы стоимостей. Главное отличие данного метода от того, что был \text{описан в разделе \ref{section:mtrx_dist} -- начальная} инициализация матрицы значением $\infty$. Если рекурсивный алгоритм выполняет вычисления для данных, которые не были обработаны, значение результата минимального расстояния для данного вызова заносится в матрицу. Если рекурсивный вызов уже обрабатывался (ячейка матрицы была заполнена), то алгоритм не выполняет вычислений, а сразу переходит к следующему шагу.

\section{Расстояние Дамерау-Левенштейна}
Расстояние Дамерау-Левенштейна является модификацией расстояния Левенштейна, которая задействует еще одну \text{редакторскую операцию -- транспозицию} $T$ (англ. \textit{transposition}), которая выполняет обмен соседних символов в слове.

Дамерау показал, что 80\% человеческих ошибок при наборе текстов является перестановка соседних символов, пропуск символа, добавление нового символа или ошибочный символ \cite{damerau_levenshtein}. Таким образом, расстояние Дамерау-Левенштейна часто используется в редакторских программах для проверки правописания.
Это расстояние может быть вычислено по \text{рекуррентной формуле (\ref{eq:damerau_levenshtein})}.
\begin{equation}
	\label{eq:damerau_levenshtein}
	D(i, j) = 
	\begin{cases}
		0, &\text{если i = 0 и j = 0,}\\
		i, &\text{если j = 0 и i > 0,}\\
		j, &\text{если i = 0 и j > 0,}\\
		\text{min} \lbrace
		D(i, j - 1) + 1,\\
		D(i - 1, j) + 1, &\text{если i > 0 и j > 0,} \\
		D(i - 1, j - 1) + f(s_{1}[i], s_{2}[j]), &\text{если $s_1[i]$ = $s_2[j - 1]$,}\\
		D(i - 2, j - 2) + 1,  &\text{если $s_1[i - 1]$ = $s_2[j]$,}\\
		\rbrace, \\
		\text{min} \lbrace
		D(i, j - 1) + 1,\\
		D(i - 1, j) + 1, &\text{иначе,}\\
		D(i - 1, j - 1) + f(s_{1}[i], s_{2}[j]), \\
		\rbrace.\\
	\end{cases}
\end{equation}
где $i$, $j$ -- длины подстроки $s_{1}[1..i]$ и $s_{2}[1..j]$ соответственно.

\section*{Вывод}
В данном разделе были проанализированы алгоритмы Левенштейна и Дамерау-Левенштейна, приведены рекуррентные формулы их вычисления, описаны использование итерационных и рекурсивных случаев выполнения каждого из них.